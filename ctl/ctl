#!/usr/bin/env bash
# This script was generated by bashly 1.2.10 (https://bashly.dev)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
	printf "bash version 4 or higher is required\n" >&2
	exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
	echo "$version"
}

# :command.usage
ctl_usage() {
	printf "ctl\n\n"

	printf "%s\n" "Usage:"
	printf "  ctl COMMAND\n"
	printf "  ctl [COMMAND] --help | -h\n"
	printf "  ctl --version | -v\n"
	echo
	# :command.usage_commands
	printf "%s\n" "Commands:"
	printf "  %s   Regenerate ctl script.\n" "bashly"
	echo

	# :command.long_usage
	if [[ -n "$long_usage" ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo
		printf "  %s\n" "--version, -v"
		printf "    Show version number\n"
		echo

	fi
}

# :command.usage
ctl_bashly_usage() {
	printf "ctl bashly - Regenerate ctl script.\n\n"

	printf "%s\n" "Usage:"
	printf "  ctl bashly\n"
	printf "  ctl bashly --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n "$long_usage" ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.normalize_input
# :command.normalize_input_function
normalize_input() {
	local arg passthru flags
	passthru=false

	while [[ $# -gt 0 ]]; do
		arg="$1"
		if [[ $passthru == true ]]; then
			input+=("$arg")
		elif [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
			input+=("${BASH_REMATCH[1]}")
			input+=("${BASH_REMATCH[2]}")
		elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
			input+=("${BASH_REMATCH[1]}")
			input+=("${BASH_REMATCH[2]}")
		elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
			flags="${BASH_REMATCH[1]}"
			for ((i = 0; i < ${#flags}; i++)); do
				input+=("-${flags:i:1}")
			done
		elif [[ "$arg" == "--" ]]; then
			passthru=true
			input+=("$arg")
		else
			input+=("$arg")
		fi

		shift
	done
}

# :command.inspect_args
inspect_args() {
	if ((${#args[@]})); then
		readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
		echo args:
		for k in "${sorted_keys[@]}"; do
			echo "- \${args[$k]} = ${args[$k]}"
		done
	else
		echo args: none
	fi

	if ((${#deps[@]})); then
		readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
		echo
		echo deps:
		for k in "${sorted_keys[@]}"; do
			echo "- \${deps[$k]} = ${deps[$k]}"
		done
	fi

	if ((${#env_var_names[@]})); then
		readarray -t sorted_names < <(printf '%s\n' "${env_var_names[@]}" | sort)
		echo
		echo "environment variables:"
		for k in "${sorted_names[@]}"; do
			echo "- \$$k = ${!k:-}"
		done
	fi
}

# :command.command_functions
# :command.function
ctl_bashly_command() {

	# src/bashly_command.sh
	# shellcheck shell=bash

	root=$(git rev-parse --show-toplevel)
	(cd "$root/ctl" && bashly generate)
	direnv reload

}

# :command.parse_requirements
parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in
			--version | -v)
				version_command
				exit
				;;

			--help | -h)
				long_usage=yes
				ctl_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action=${1:-}

	case $action in
		-*) ;;

		bashly)
			action="bashly"
			shift
			ctl_bashly_parse_requirements "$@"
			shift $#
			;;

		# :command.command_fallback
		"")
			ctl_usage >&2
			exit 1
			;;

		*)
			printf "invalid command: %s\n" "$action" >&2
			exit 1
			;;

	esac

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
ctl_bashly_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in
			--help | -h)
				long_usage=yes
				ctl_bashly_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="bashly"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.initialize
initialize() {
	declare -g version="1.0.0"
	set -e

}

# :command.run
run() {
	# :command.globals
	declare -g long_usage=''
	declare -g -A args=()
	declare -g -A deps=()
	declare -g -a env_var_names=()
	declare -g -a input=()

	normalize_input "$@"
	parse_requirements "${input[@]}"

	case "$action" in
		"bashly") ctl_bashly_command ;;
	esac
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
	initialize
	run "$@"
fi
