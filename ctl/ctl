#!/usr/bin/env bash
# This script was generated by bashly 1.2.10 (https://bashly.dev)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
	printf "bash version 4 or higher is required\n" >&2
	exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
	echo "$version"
}

# :command.usage
ctl_usage() {
	printf "ctl\n\n"

	printf "%s\n" "Usage:"
	printf "  ctl COMMAND\n"
	printf "  ctl [COMMAND] --help | -h\n"
	printf "  ctl --version | -v\n"
	echo
	# :command.usage_commands
	printf "%s\n" "Commands:"
	printf "  %s   Regenerate ctl script.\n" "bashly   "
	printf "  %s   Write the Outpost Bootstrap iso image to a device.\n" "bootstrap"
	printf "  %s   Push configuration to Outpost.\n" "deploy   "
	echo

	# :command.long_usage
	if [[ -n "$long_usage" ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo
		printf "  %s\n" "--version, -v"
		printf "    Show version number\n"
		echo

	fi
}

# :command.usage
ctl_bashly_usage() {
	printf "ctl bashly - Regenerate ctl script.\n\n"

	printf "%s\n" "Usage:"
	printf "  ctl bashly\n"
	printf "  ctl bashly --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n "$long_usage" ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
ctl_bootstrap_usage() {
	printf "ctl bootstrap - Write the Outpost Bootstrap iso image to a device.\n\n"

	printf "%s\n" "Usage:"
	printf "  ctl bootstrap DEVICE [OPTIONS]\n"
	printf "  ctl bootstrap --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n "$long_usage" ]]; then
		printf "%s\n" "Options:"

		# :command.usage_flags
		# :flag.usage
		printf "  %s\n" "--yes, -y"
		printf "    Perform operation without user prompts.\n"
		echo

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_args
		printf "%s\n" "Arguments:"

		# :argument.usage
		printf "  %s\n" "DEVICE"
		printf "    Name of device.\n"
		echo

		# :command.usage_examples
		printf "%s\n" "Examples:"
		printf "  ctl bootstrap /dev/sdb\n"
		printf "  ctl bootstrap /dev/sdb --yes\n"
		echo

	fi
}

# :command.usage
ctl_deploy_usage() {
	printf "ctl deploy - Push configuration to Outpost.\n\n"

	printf "%s\n" "Usage:"
	printf "  ctl deploy\n"
	printf "  ctl deploy --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n "$long_usage" ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_examples
		printf "%s\n" "Examples:"
		printf "  ctl deploy\n"
		echo

	fi
}

# :command.normalize_input
# :command.normalize_input_function
normalize_input() {
	local arg passthru flags
	passthru=false

	while [[ $# -gt 0 ]]; do
		arg="$1"
		if [[ $passthru == true ]]; then
			input+=("$arg")
		elif [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
			input+=("${BASH_REMATCH[1]}")
			input+=("${BASH_REMATCH[2]}")
		elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
			input+=("${BASH_REMATCH[1]}")
			input+=("${BASH_REMATCH[2]}")
		elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
			flags="${BASH_REMATCH[1]}"
			for ((i = 0; i < ${#flags}; i++)); do
				input+=("-${flags:i:1}")
			done
		elif [[ "$arg" == "--" ]]; then
			passthru=true
			input+=("$arg")
		else
			input+=("$arg")
		fi

		shift
	done
}

# :command.inspect_args
inspect_args() {
	if ((${#args[@]})); then
		readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
		echo args:
		for k in "${sorted_keys[@]}"; do
			echo "- \${args[$k]} = ${args[$k]}"
		done
	else
		echo args: none
	fi

	if ((${#deps[@]})); then
		readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
		echo
		echo deps:
		for k in "${sorted_keys[@]}"; do
			echo "- \${deps[$k]} = ${deps[$k]}"
		done
	fi

	if ((${#env_var_names[@]})); then
		readarray -t sorted_names < <(printf '%s\n' "${env_var_names[@]}" | sort)
		echo
		echo "environment variables:"
		for k in "${sorted_names[@]}"; do
			echo "- \$$k = ${!k:-}"
		done
	fi
}

# :command.command_functions
# :command.function
ctl_bashly_command() {

	# src/bashly_command.sh
	# shellcheck shell=bash

	root=$(git rev-parse --show-toplevel)
	(cd "$root/ctl" && bashly generate)
	direnv reload

}

# :command.function
ctl_bootstrap_command() {

	# src/bootstrap_command.sh
	# shellcheck shell=bash

	device_path="${args[device]}"
	yes="${args[--yes]}"

	if [ -n "$yes" ]; then
		# Refresh sudo credentials if necessary.
		sudo -v
	fi

	store_path=$(nix build .#bootstrap --print-out-paths)
	iso_path_files=("$store_path/iso/nixos-"*.iso)
	iso_path="${iso_path_files[0]}"
	if [ ! -f "$iso_path" ]; then
		echo "could not find bootstrap iso in store path $iso_path"
		exit 1
	fi

	unset write
	if [ -n "$yes" ]; then
		write=1
	else
		echo "Do you want to write $iso_path to $device_path? (y/N)"
		read -r answer
		if [[ "$answer" =~ ^[Yy]$ ]]; then
			write=1
		fi
	fi

	if [ -n "$write" ]; then
		echo "writing to device..."
		sudo dd bs=4M if="$iso_path" of="$device_path" status=progress conv=fsync
	else
		echo "cancelled"
	fi

}

# :command.function
ctl_deploy_command() {

	# src/deploy_command.sh
	# shellcheck shell=bash

	deploy

}

# :command.parse_requirements
parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in
			--version | -v)
				version_command
				exit
				;;

			--help | -h)
				long_usage=yes
				ctl_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action=${1:-}

	case $action in
		-*) ;;

		bashly)
			action="bashly"
			shift
			ctl_bashly_parse_requirements "$@"
			shift $#
			;;

		bootstrap)
			action="bootstrap"
			shift
			ctl_bootstrap_parse_requirements "$@"
			shift $#
			;;

		deploy)
			action="deploy"
			shift
			ctl_deploy_parse_requirements "$@"
			shift $#
			;;

		# :command.command_fallback
		"")
			ctl_usage >&2
			exit 1
			;;

		*)
			printf "invalid command: %s\n" "$action" >&2
			exit 1
			;;

	esac

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
ctl_bashly_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in
			--help | -h)
				long_usage=yes
				ctl_bashly_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="bashly"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
ctl_bootstrap_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in
			--help | -h)
				long_usage=yes
				ctl_bootstrap_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="bootstrap"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in
			# :flag.case
			--yes | -y)

				# :flag.case_no_arg
				args['--yes']=1
				shift
				;;

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				# :argument.case
				if [[ -z ${args['device']+x} ]]; then
					args['device']=$1
					shift
				else
					printf "invalid argument: %s\n" "$key" >&2
					exit 1
				fi

				;;

		esac
	done

	# :command.required_args_filter
	if [[ -z ${args['device']+x} ]]; then
		printf "missing required argument: DEVICE\nusage: ctl bootstrap DEVICE [OPTIONS]\n" >&2

		exit 1
	fi

}

# :command.parse_requirements
ctl_deploy_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in
			--help | -h)
				long_usage=yes
				ctl_deploy_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="deploy"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.initialize
initialize() {
	declare -g version="1.0.0"
	set -e

}

# :command.run
run() {
	# :command.globals
	declare -g long_usage=''
	declare -g -A args=()
	declare -g -A deps=()
	declare -g -a env_var_names=()
	declare -g -a input=()

	normalize_input "$@"
	parse_requirements "${input[@]}"

	case "$action" in
		"bashly") ctl_bashly_command ;;
		"bootstrap") ctl_bootstrap_command ;;
		"deploy") ctl_deploy_command ;;
	esac
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
	initialize
	run "$@"
fi
